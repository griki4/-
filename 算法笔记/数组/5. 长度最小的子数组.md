## 长度最小的子数组

力扣209-长度最小的子数组：https://leetcode.cn/problems/minimum-size-subarray-sum/

### 1.暴力解法

这道题最容易想到的思路就是两层for循环，首先找出所有满足条件的子数组，然后从这些子数组中找出长度最小的即可。两层循环事件复杂度自然就是O(n2)，目前力扣更新了数据，该解法提交时会提示超时。

### 2.滑动窗口

本题也有一个特点，要求子数组是连续的，由此才能使用**滑动窗口**的解法解决。所谓滑动窗口，其实也是双指针的一种，不过在滑动窗口中我们更加关心的是出于两个指针之间的所有的元素，而不仅仅是两个指针所指的元素。

滑动窗口解法的核心就是不断调整子序列的起始位置和终止位置，从而得到答案。要学会滑动窗口，最核心的问题有三个。

- 窗口内是什么？
- 起始位置如何移动？
- 终止位置如何移动？

在本体中，窗口内就是满足题目要求的子数组。

在了解起始位置如何移动前，需要了解终止位置如何移动。滑动窗口解法其实就是利用一层循环去解决两层循环才能做到的事情，在这一层循环中我们应该是移动起始位置还是终止位置呢？假设我们移动起始位置，那么终止位置就应该遍历起始位置之后的所有元素，找到所有的子数组，最后从子数组中找到长度最小的。不难发现，这样做的话就是上面提及的暴力解法了，很明显这是没有意义的。

这么说应该移动终止位置，这又是为何呢？还是回到双指针的本质，快指针也即本题中的终止位置指针，是去搜集符合条件的元素的，只是这是快指针是不断移动并纳入元素，直到它和慢指针之间的子数组之和大于目标值。这就是终止位置指针的含义和移动方法。

而起始位置的指针，就是在终止位置指针指向某一个元素时刚好满足题目要求，起始指针移动，它移动的目的是寻求缩短子数组的可能性，如果起始指针移动之后子数组依然满足要求那就继续移动直到子数组不符合要求。此时终止位置指针再次启动，然后重复上述步骤即可。

弄懂了上面三个核心问题，滑动窗口的问题就迎刃而解了。尤其是起始位置的指针的移动条件，它是最为关键的一步。同时如果题目中出现连续子序列相关的字眼时，就可以考虑使用滑动窗口的方式进行解决。

代码如下：

```javascript
var minSubArrayLen = function(target, nums) {
    let i = 0//定义起始位置指针
    let sum = 0//记录子数组和的变量
    let result = Infinity//定义一个无穷大变量，用于记录并更新满足条件的长度最小子数组的长度
    for (let j = 0; j < nums.length; j++){//定义终止位置指针，一定是先移动终止位置指针
        sum += nums[j]//不断将遍历到的元素纳入子数组
        while (sum >= target) {//满足条件，此时终止位置指针暂停移动，尝试移动起始位置指针
            result = Math.min(result, j - i + 1)
            sum -= nums[i]
            i++//移动起始位置指针并进入下一次循环
        }
    }
    return result === Infinity ? 0 : result //没有满足条件的子数组时返回0
};
```

