## 反转链表

[力扣206-反转链表](https://leetcode.cn/problems/reverse-linked-list/)

反转链表是一道非常经典的考察对于基础数据结构操作的题目，从我个人看的一些面经上面来看，这道题出现在面试中的频率是非常高的。因此需要重点掌握。本题有两种解法，双指针和递归，而递归解法又可以参考双指针解法得出，因此，**本题最重要的是掌握双指针解法。**

### 1.双指针法

反转链表的核心就是修改链表元素的next指针方向，需要将原本指向链表下一个元素的指针指向上一个元素，对所有的链表元素都进行这样的操作就可以实现链表的反转。

因此双指针所指向的元素就显而易见了，一个指针指向当前节点，另一个指针指向当前节点的上一个节点，然后修改指针指向即可。因此初始化一个cur指针，指向链表的头结点，链表反转之后，头结点变成尾结点，其next指针指向null，**因此头结点的上一个节点就是`null`**。初始化一个pre指针指向null，然后开始进行移动指针的操作。

移动指针操作涉及本题第二个难点，循环终止条件。什么时候终止操作，当cur指向链表的尾结点的时候我们依然要进行操作，而当cur指向null，即pre指向尾结点的时候就无需再操作了。所以终止条件就是cur指针不为null。

代码：

```javascript
//1.双指针法
var reverseList = function (head) {
    //没有节点或者只有一个节点的时候，直接返回头节点即可
    if (!head || !head.next) return head
    //pre指向头节点之前的一个节点，初始为null
    //cur初始时指向头节点
    //temp初始指向头节点之后的一个节点的元素
    let pre = null, temp = null, cur = head
    while (cur) {
        //保存cur指针之后的节点，temp并非指针而是一个临时变量。temp的存在是为了cur指针在修改next指向之后，还能够继续遍历链表
        //寻找链表的下一个节点
        temp = cur.next
        //修改链表的方向，指向前一个节点
        cur.next = pre
        //指针移动，注意应该先移动pre指针，否则无法找到pre指针应该移动到的下一个节点
        //cur指针的下一个节点使用temp保存了但是pre没有
        pre = cur
        cur = temp
    }
    return pre
};
```

### 2.递归解法

然后是递归解法，面试的时候除非面试官明确要求使用递归解法否则一律使用双指针，避免面试的时候把自己绕晕。

依旧是双指针的解法，不过能用递归解决的问题一般都有共同点，就是大问题可以拆分成子问题并且子问题和大问题的解法相同。本题就可以拆解为当链表中只有两个节点的时候如何反转链表，这个操作相当简单

```javascript
head.next.next = head.next
head.next = null
```

我们可以将链表拆分，分为第一个节点，以及后续节点组成的“大节点”，这样链表中可以视为只有两个节点，按照上述操作进行反转即可。

```javascript
var reverseList = function (head) {
    if (!head || !head.next) return head
    //链表的拆分
    const p = reverseList(head.next)
    //设置递归的终止条件以及在递归的终点需要执行的操作
    //头节点下一个节点的下一个节点是头节点
    head.next.next = head
    //头节点的下一个节点是null
    head.next = null
    return p
}
```

